{"version":3,"sources":["webpack://wp/webpack/bootstrap","webpack://wp/@wordpress/dom/src/dom.js","webpack://wp/@wordpress/dom/src/focusable.js","webpack://wp/@wordpress/dom/src/index.js","webpack://wp/@wordpress/dom/src/tabbable.js","webpack://wp/external {\"this\":\"lodash\"}"],"names":["window","DOMParser","getComputedStyle","Node","TEXT_NODE","ELEMENT_NODE","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","isSelectionForward","selection","anchorNode","focusNode","anchorOffset","focusOffset","position","compareDocumentPosition","isEdge","container","isReverse","onlyVertical","includes","tagName","selectionStart","selectionEnd","value","length","isContentEditable","getSelection","rangeCount","originalRange","getRangeAt","range","cloneRange","isForward","isCollapsed","collapse","rangeRect","getRectangleFromRange","computedStyle","lineHeight","parseInt","height","padding","buffer","containerRect","getBoundingClientRect","originalRangeRect","verticalEdge","top","bottom","direction","isReverseDir","x","left","right","y","testRange","hiddenCaretRangeFromPoint","document","side","testRect","Math","abs","isHorizontalEdge","isVerticalEdge","collapsed","startContainer","nodeName","parentNode","index","Array","from","childNodes","indexOf","createRange","setStart","setEnd","rect","getClientRects","padNode","createTextNode","insertNode","removeChild","computeCaretRect","placeCaretAtHorizontalEdge","focus","rangeTarget","selectNodeContents","removeAllRanges","addRange","caretRangeFromPoint","doc","caretPositionFromPoint","point","offsetNode","offset","originalZIndex","style","zIndex","originalPosition","placeCaretAtVerticalEdge","mayUseScroll","editableRect","contains","scrollIntoView","isTextField","element","contentEditable","error","documentHasSelection","activeElement","isEntirelySelected","endContainer","startOffset","endOffset","lastChild","lastChildContentLength","nodeType","data","firstChild","getScrollContainer","node","scrollHeight","clientHeight","overflowY","test","getOffsetParent","closestElement","offsetParent","replace","processedNode","newNode","insertAfter","remove","referenceNode","insertBefore","nextSibling","unwrap","parent","replaceTag","ownerDocument","createElement","appendChild","replaceChild","wrap","__unstableStripHTML","html","parseFromString","body","textContent","SELECTOR","join","isVisible","offsetWidth","offsetHeight","isValidFocusableArea","map","closest","img","querySelector","name","find","context","elements","querySelectorAll","filter","focusable","tabbable","getTabIndex","tabIndex","getAttribute","isTabbableIndex","createStatefulCollapseRadioGroup","CHOSEN_RADIO_BY_NAME","collapseRadioGroup","result","type","checked","concat","hasChosen","hasOwnProperty","isChosen","hadChosenElement","without","mapElementToObjectTabbable","mapObjectTabbableToElement","object","compareObjectTabbables","a","b","aTabIndex","bTabIndex","filterTabbable","focusables","sort","reduce","findFocusable","findPrevious","last","findNext","remaining","slice","first"],"mappings":"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","file":"dom.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/@wordpress/dom/build-module/index.js\");\n","/**\n * External dependencies\n */\nimport { includes } from 'lodash';\n\n/**\n * Browser dependencies\n */\n\nconst { DOMParser, getComputedStyle } = window;\nconst {\n\tTEXT_NODE,\n\tELEMENT_NODE,\n\tDOCUMENT_POSITION_PRECEDING,\n\tDOCUMENT_POSITION_FOLLOWING,\n} = window.Node;\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nfunction isSelectionForward( selection ) {\n\tconst { anchorNode, focusNode, anchorOffset, focusOffset } = selection;\n\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {Element} container    Focusable element.\n * @param {boolean} isReverse    Set to true to check left, false to check right.\n * @param {boolean} onlyVertical Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nfunction isEdge( container, isReverse, onlyVertical ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\n\tif ( ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst originalRange = selection.getRangeAt( 0 );\n\tconst range = originalRange.cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\trange.collapse( ! isForward );\n\t}\n\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\tconst computedStyle = window.getComputedStyle( container );\n\tconst lineHeight = parseInt( computedStyle.lineHeight, 10 ) || 0;\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge.\n\tif (\n\t\t! isCollapsed &&\n\t\trangeRect.height > lineHeight &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\tconst padding =\n\t\tparseInt(\n\t\t\tcomputedStyle[ `padding${ isReverse ? 'Top' : 'Bottom' }` ],\n\t\t\t10\n\t\t) || 0;\n\n\t// Calculate a buffer that is half the line height. In some browsers, the\n\t// selection rectangle may not fill the entire height of the line, so we add\n\t// 3/4 the line height to the selection rectangle to ensure that it is well\n\t// over its line boundary.\n\tconst buffer = ( 3 * parseInt( lineHeight, 10 ) ) / 4;\n\tconst containerRect = container.getBoundingClientRect();\n\tconst originalRangeRect = getRectangleFromRange( originalRange );\n\tconst verticalEdge = isReverse\n\t\t? containerRect.top + padding > originalRangeRect.top - buffer\n\t\t: containerRect.bottom - padding < originalRangeRect.bottom + buffer;\n\n\tif ( ! verticalEdge ) {\n\t\treturn false;\n\t}\n\n\tif ( onlyVertical ) {\n\t\treturn true;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst { direction } = computedStyle;\n\tconst isReverseDir = direction === 'rtl' ? ! isReverse : isReverse;\n\n\t// To calculate the horizontal position, we insert a test range and see if\n\t// this test range has the same horizontal position. This method proves to\n\t// be better than a DOM-based calculation, because it ignores empty text\n\t// nodes and a trailing line break element. In other words, we need to check\n\t// visual positioning, not DOM positioning.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse\n\t\t? containerRect.top + buffer\n\t\t: containerRect.bottom - buffer;\n\tconst testRange = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst side = isReverseDir ? 'left' : 'right';\n\tconst testRect = getRectangleFromRange( testRange );\n\n\t// Allow the position to be 1px off.\n\treturn Math.abs( testRect[ side ] - rangeRect[ side ] ) <= 1;\n}\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport function isHorizontalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse );\n}\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the vertical edge, false if not.\n */\nexport function isVerticalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse, true );\n}\n\n/**\n * Get the rectangle of a given Range.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect} The rectangle.\n */\nexport function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\treturn range.getBoundingClientRect();\n\t}\n\n\tconst { startContainer } = range;\n\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\n\tif ( startContainer.nodeName === 'BR' ) {\n\t\tconst { parentNode } = startContainer;\n\t\tconst index = Array.from( parentNode.childNodes ).indexOf(\n\t\t\tstartContainer\n\t\t);\n\n\t\trange = document.createRange();\n\t\trange.setStart( parentNode, index );\n\t\trange.setEnd( parentNode, index );\n\t}\n\n\tlet rect = range.getClientRects()[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect ) {\n\t\tconst padNode = document.createTextNode( '\\u200b' );\n\t\t// Do not modify the live range.\n\t\trange = range.cloneRange();\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @return {?DOMRect} The rectangle.\n */\nexport function computeCaretRect() {\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse True for end, false for start.\n */\nexport function placeCaretAtHorizontalEdge( container, isReverse ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tcontainer.focus();\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\t// Select on extent child of the container, not the container itself. This\n\t// avoids the selection always being `endOffset` of 1 when placed at end,\n\t// where `startContainer`, `endContainer` would always be container itself.\n\tconst rangeTarget = container[ isReverse ? 'lastChild' : 'firstChild' ];\n\n\t// If no range target, it implies that the container is empty. Focusing is\n\t// sufficient for caret to be placed correctly.\n\tif ( ! rangeTarget ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = document.createRange();\n\n\trange.selectNodeContents( rangeTarget );\n\trange.collapse( ! isReverse );\n\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {Document} doc The document of the range.\n * @param {number}    x   Horizontal position within the current viewport.\n * @param {number}    y   Vertical position within the current viewport.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document} doc       The document of the range.\n * @param {number}    x         Horizontal position within the current viewport.\n * @param {number}    y         Vertical position within the current viewport.\n * @param {Element}  container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tconst originalZIndex = container.style.zIndex;\n\tconst originalPosition = container.style.position;\n\n\t// A z-index only works if the element position is not static.\n\tcontainer.style.zIndex = '10000';\n\tcontainer.style.position = 'relative';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = originalZIndex;\n\tcontainer.style.position = originalPosition;\n\n\treturn range;\n}\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {Element} container           Focusable element.\n * @param {boolean} isReverse           True for bottom, false for top.\n * @param {DOMRect} [rect]              The rectangle to position the caret with.\n * @param {boolean} [mayUseScroll=true] True to allow scrolling, false to disallow.\n */\nexport function placeCaretAtVerticalEdge(\n\tcontainer,\n\tisReverse,\n\trect,\n\tmayUseScroll = true\n) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( ! rect || ! container.isContentEditable ) {\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Offset by a buffer half the height of the caret rect. This is needed\n\t// because caretRangeFromPoint may default to the end of the selection if\n\t// offset is too close to the edge. It's unclear how to precisely calculate\n\t// this threshold; it may be the padded area of some combination of line\n\t// height, caret height, and font size. The buffer offset is effectively\n\t// equivalent to a point at half the height of a line of text.\n\tconst buffer = rect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\tconst x = rect.left;\n\tconst y = isReverse\n\t\t? editableRect.bottom - buffer\n\t\t: editableRect.top + buffer;\n\n\tconst range = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! range || ! container.contains( range.startContainer ) ) {\n\t\tif (\n\t\t\tmayUseScroll &&\n\t\t\t( ! range ||\n\t\t\t\t! range.startContainer ||\n\t\t\t\t! range.startContainer.contains( container ) )\n\t\t) {\n\t\t\t// Might be out of view.\n\t\t\t// Easier than attempting to calculate manually.\n\t\t\tcontainer.scrollIntoView( isReverse );\n\t\t\tplaceCaretAtVerticalEdge( container, isReverse, rect, false );\n\t\t\treturn;\n\t\t}\n\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n\tcontainer.focus();\n\t// Editable was already focussed, it goes back to old range...\n\t// This fixes it.\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is an text field, false if not.\n */\nexport function isTextField( element ) {\n\ttry {\n\t\tconst { nodeName, selectionStart, contentEditable } = element;\n\n\t\treturn (\n\t\t\t( nodeName === 'INPUT' && selectionStart !== null ) ||\n\t\t\tnodeName === 'TEXTAREA' ||\n\t\t\tcontentEditable === 'true'\n\t\t);\n\t} catch ( error ) {\n\t\t// Safari throws an exception when trying to get `selectionStart`\n\t\t// on non-text <input> elements (which, understandably, don't\n\t\t// have the text selection API). We catch this via a try/catch\n\t\t// block, as opposed to a more explicit check of the element's\n\t\t// input types, because of Safari's non-standard behavior. This\n\t\t// also means we don't have to worry about the list of input\n\t\t// types that support `selectionStart` changing as the HTML spec\n\t\t// evolves over time.\n\t\treturn false;\n\t}\n}\n\n/**\n * Check wether the current document has a selection.\n * This checks both for focus in an input field and general text selection.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasSelection() {\n\tif ( isTextField( document.activeElement ) ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\treturn range && ! range.collapsed;\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport function isEntirelySelected( element ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], element.nodeName ) ) {\n\t\treturn (\n\t\t\telement.selectionStart === 0 &&\n\t\t\telement.value.length === element.selectionEnd\n\t\t);\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\tif (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = element.lastChild;\n\tconst lastChildContentLength =\n\t\tlastChild.nodeType === TEXT_NODE\n\t\t\t? lastChild.data.length\n\t\t\t: lastChild.childNodes.length;\n\n\treturn (\n\t\tstartContainer === element.firstChild &&\n\t\tendContainer === element.lastChild &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === lastChildContentLength\n\t);\n}\n\n/**\n * Given a DOM node, finds the closest scrollable container node.\n *\n * @param {Element} node Node from which to start.\n *\n * @return {?Element} Scrollable container node, if found.\n */\nexport function getScrollContainer( node ) {\n\tif ( ! node ) {\n\t\treturn;\n\t}\n\n\t// Scrollable if scrollable height exceeds displayed...\n\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t// ...except when overflow is defined to be hidden or visible\n\t\tconst { overflowY } = window.getComputedStyle( node );\n\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// Continue traversing\n\treturn getScrollContainer( node.parentNode );\n}\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {?Node} Offset parent.\n */\nexport function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = node.parentNode ) ) {\n\t\tif ( closestElement.nodeType === ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif ( getComputedStyle( closestElement ).position !== 'static' ) {\n\t\treturn closestElement;\n\t}\n\n\treturn closestElement.offsetParent;\n}\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport function replace( processedNode, newNode ) {\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Element} node Node to be removed.\n * @return {void}\n */\nexport function remove( node ) {\n\tnode.parentNode.removeChild( node );\n}\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Element} newNode       Node to be inserted.\n * @param {Element} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport function insertAfter( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element}  node    The node to replace\n * @param {string}   tagName The new tag name.\n *\n * @return {Element} The new node.\n */\nexport function replaceTag( node, tagName ) {\n\tconst newNode = node.ownerDocument.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n\n/**\n * Wraps the given node with a new node with the given tag name.\n *\n * @param {Element} newNode       The node to insert.\n * @param {Element} referenceNode The node to wrap.\n */\nexport function wrap( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\n\tnewNode.appendChild( referenceNode );\n}\n\n/**\n * Removes any HTML tags from the provided string.\n *\n * @param {string} html The string containing html.\n *\n * @return {string} The text content with any html removed.\n */\nexport function __unstableStripHTML( html ) {\n\tconst document = new DOMParser().parseFromString( html, 'text/html' );\n\treturn document.body.textContent || '';\n}\n","/**\n * References:\n *\n * Focusable:\n *  - https://www.w3.org/TR/html5/editing.html#focus-management\n *\n * Sequential focus navigation:\n *  - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\n *\n * Disabled elements:\n *  - https://www.w3.org/TR/html5/disabled-elements.html#disabled-elements\n *\n * getClientRects algorithm (requiring layout box):\n *  - https://www.w3.org/TR/cssom-view-1/#extension-to-the-element-interface\n *\n * AREA elements associated with an IMG:\n *  - https://w3c.github.io/html/editing.html#data-model\n */\n\nconst SELECTOR = [\n\t'[tabindex]',\n\t'a[href]',\n\t'button:not([disabled])',\n\t'input:not([type=\"hidden\"]):not([disabled])',\n\t'select:not([disabled])',\n\t'textarea:not([disabled])',\n\t'iframe',\n\t'object',\n\t'embed',\n\t'area[href]',\n\t'[contenteditable]:not([contenteditable=false])',\n].join( ',' );\n\n/**\n * Returns true if the specified element is visible (i.e. neither display: none\n * nor visibility: hidden).\n *\n * @param {Element} element DOM element to test.\n *\n * @return {boolean} Whether element is visible.\n */\nfunction isVisible( element ) {\n\treturn (\n\t\telement.offsetWidth > 0 ||\n\t\telement.offsetHeight > 0 ||\n\t\telement.getClientRects().length > 0\n\t);\n}\n\n/**\n * Returns true if the specified area element is a valid focusable element, or\n * false otherwise. Area is only focusable if within a map where a named map\n * referenced by an image somewhere in the document.\n *\n * @param {Element} element DOM area element to test.\n *\n * @return {boolean} Whether area element is valid for focus.\n */\nfunction isValidFocusableArea( element ) {\n\tconst map = element.closest( 'map[name]' );\n\tif ( ! map ) {\n\t\treturn false;\n\t}\n\n\tconst img = document.querySelector( 'img[usemap=\"#' + map.name + '\"]' );\n\treturn !! img && isVisible( img );\n}\n\n/**\n * Returns all focusable elements within a given context.\n *\n * @param {Element} context Element in which to search.\n *\n * @return {Element[]} Focusable elements.\n */\nexport function find( context ) {\n\tconst elements = context.querySelectorAll( SELECTOR );\n\n\treturn Array.from( elements ).filter( ( element ) => {\n\t\tif ( ! isVisible( element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { nodeName } = element;\n\t\tif ( 'AREA' === nodeName ) {\n\t\t\treturn isValidFocusableArea( element );\n\t\t}\n\n\t\treturn true;\n\t} );\n}\n","/**\n * Internal dependencies\n */\nimport * as focusable from './focusable';\nimport * as tabbable from './tabbable';\n\n/**\n * Object grouping `focusable` and `tabbable` utils\n * under the keys with the same name.\n */\nexport const focus = { focusable, tabbable };\n\nexport * from './dom';\n","/**\n * External dependencies\n */\nimport { without, first, last } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport { find as findFocusable } from './focusable';\n\n/**\n * Returns the tab index of the given element. In contrast with the tabIndex\n * property, this normalizes the default (0) to avoid browser inconsistencies,\n * operating under the assumption that this function is only ever called with a\n * focusable node.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261\n *\n * @param {Element} element Element from which to retrieve.\n *\n * @return {?number} Tab index of element (default 0).\n */\nfunction getTabIndex( element ) {\n\tconst tabIndex = element.getAttribute( 'tabindex' );\n\treturn tabIndex === null ? 0 : parseInt( tabIndex, 10 );\n}\n\n/**\n * Returns true if the specified element is tabbable, or false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is tabbable.\n */\nexport function isTabbableIndex( element ) {\n\treturn getTabIndex( element ) !== -1;\n}\n\n/**\n * Returns a stateful reducer function which constructs a filtered array of\n * tabbable elements, where at most one radio input is selected for a given\n * name, giving priority to checked input, falling back to the first\n * encountered.\n *\n * @return {Function} Radio group collapse reducer.\n */\nfunction createStatefulCollapseRadioGroup() {\n\tconst CHOSEN_RADIO_BY_NAME = {};\n\n\treturn function collapseRadioGroup( result, element ) {\n\t\tconst { nodeName, type, checked, name } = element;\n\n\t\t// For all non-radio tabbables, construct to array by concatenating.\n\t\tif ( nodeName !== 'INPUT' || type !== 'radio' || ! name ) {\n\t\t\treturn result.concat( element );\n\t\t}\n\n\t\tconst hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty( name );\n\n\t\t// Omit by skipping concatenation if the radio element is not chosen.\n\t\tconst isChosen = checked || ! hasChosen;\n\t\tif ( ! isChosen ) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// At this point, if there had been a chosen element, the current\n\t\t// element is checked and should take priority. Retroactively remove\n\t\t// the element which had previously been considered the chosen one.\n\t\tif ( hasChosen ) {\n\t\t\tconst hadChosenElement = CHOSEN_RADIO_BY_NAME[ name ];\n\t\t\tresult = without( result, hadChosenElement );\n\t\t}\n\n\t\tCHOSEN_RADIO_BY_NAME[ name ] = element;\n\n\t\treturn result.concat( element );\n\t};\n}\n\n/**\n * An array map callback, returning an object with the element value and its\n * array index location as properties. This is used to emulate a proper stable\n * sort where equal tabIndex should be left in order of their occurrence in the\n * document.\n *\n * @param {Element} element Element.\n * @param {number}  index   Array index of element.\n *\n * @return {Object} Mapped object with element, index.\n */\nfunction mapElementToObjectTabbable( element, index ) {\n\treturn { element, index };\n}\n\n/**\n * An array map callback, returning an element of the given mapped object's\n * element value.\n *\n * @param {Object} object Mapped object with index.\n *\n * @return {Element} Mapped object element.\n */\nfunction mapObjectTabbableToElement( object ) {\n\treturn object.element;\n}\n\n/**\n * A sort comparator function used in comparing two objects of mapped elements.\n *\n * @see mapElementToObjectTabbable\n *\n * @param {Object} a First object to compare.\n * @param {Object} b Second object to compare.\n *\n * @return {number} Comparator result.\n */\nfunction compareObjectTabbables( a, b ) {\n\tconst aTabIndex = getTabIndex( a.element );\n\tconst bTabIndex = getTabIndex( b.element );\n\n\tif ( aTabIndex === bTabIndex ) {\n\t\treturn a.index - b.index;\n\t}\n\n\treturn aTabIndex - bTabIndex;\n}\n\n/**\n * Givin focusable elements, filters out tabbable element.\n *\n * @param {Array} focusables Focusable elements to filter.\n *\n * @return {Array} Tabbable elements.\n */\nfunction filterTabbable( focusables ) {\n\treturn focusables\n\t\t.filter( isTabbableIndex )\n\t\t.map( mapElementToObjectTabbable )\n\t\t.sort( compareObjectTabbables )\n\t\t.map( mapObjectTabbableToElement )\n\t\t.reduce( createStatefulCollapseRadioGroup(), [] );\n}\n\nexport function find( context ) {\n\treturn filterTabbable( findFocusable( context ) );\n}\n\n/**\n * Given a focusable element, find the preceding tabbable element.\n *\n * @param {Element} element The focusable element before which to look. Defaults\n *                          to the active element.\n */\nexport function findPrevious( element = document.activeElement ) {\n\tconst focusables = findFocusable( document.body );\n\tconst index = focusables.indexOf( element );\n\n\t// Remove all focusables after and including `element`.\n\tfocusables.length = index;\n\n\treturn last( filterTabbable( focusables ) );\n}\n\n/**\n * Given a focusable element, find the next tabbable element.\n *\n * @param {Element} element The focusable element after which to look. Defaults\n *                          to the active element.\n */\nexport function findNext( element = document.activeElement ) {\n\tconst focusables = findFocusable( document.body );\n\tconst index = focusables.indexOf( element );\n\n\t// Remove all focusables before and inside `element`.\n\tconst remaining = focusables\n\t\t.slice( index + 1 )\n\t\t.filter( ( node ) => ! element.contains( node ) );\n\n\treturn first( filterTabbable( remaining ) );\n}\n","(function() { module.exports = this[\"lodash\"]; }());"],"sourceRoot":""}